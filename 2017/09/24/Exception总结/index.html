<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Exception总结 · 技术成长</title><meta name="description" content="Exception总结 - 曹林华"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://tylercao.coding.me/blog/atom.xml" title="技术成长"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/resume" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="https://weibo.com/caolinhua" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="https://github.com/tylercao" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Exception总结</h1><div class="post-info">2017年9月24日</div><div class="post-content"><h3 id="Empty集合处理"><a href="#Empty集合处理" class="headerlink" title="Empty集合处理"></a>Empty集合处理</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>函数是应当返回null还是长度为0的数组（或集合）？</p>
<a id="more"></a>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>返回零长度的数组或集合而不是null</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>如果返回empty，就可以少了很多NOT-NULL判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; list = queryPerson();  </span><br><span class="line">if (list != null) &#123;  </span><br><span class="line">    for (Person p : list) &#123;  </span><br><span class="line">        //do something  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果queryPerson永不返回null，那代码可以这样（如果有粗心的程序员或者自己忘了判断null）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; list = queryPerson();  </span><br><span class="line">for (Person p : list) &#123;  </span><br><span class="line">    //do something  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>遵守这个规则的一个例子就是Spring JdbcTemplate的query方法，在查询不到结果时，返回的是empty List： RowMapperResultSetExtractor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;T&gt; extractData(ResultSet rs) throws SQLException &#123;  </span><br><span class="line">    List&lt;T&gt; results = (this.rowsExpected &gt; 0 ? new ArrayList&lt;T&gt;(this.rowsExpected) : new ArrayList&lt;T&gt;());  </span><br><span class="line">    int rowNum = 0;  </span><br><span class="line">      </span><br><span class="line">    while (rs.next()) &#123;  </span><br><span class="line">        results.add(this.rowMapper.mapRow(rs, rowNum++));  </span><br><span class="line">    &#125;  </span><br><span class="line">    return results;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Exception实践"><a href="#Exception实践" class="headerlink" title="Exception实践"></a>Exception实践</h3><h4 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h4><p>什么时候用Exception呢？</p>
<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><ol>
<li>异常不应该被用来控制正常的控制流,但可以用来替换不正常的控制流。</li>
<li>正常的业务流程分支中不能用异常来控制，但是业务流程的不可恢复动作或者结束可以采用异常来处理<h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4>用户登录失败，如果查询不到用户，就通过异常返回<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User user = dao.getUser();</span><br><span class="line">if (user != null) &#123;</span><br><span class="line">    throw new UserNotExistExcption(&quot;User not exist&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注册用户,如果手机号不存在，就创建新用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String mobile = 1234</span><br><span class="line">User user = dao.getUser(mobile);</span><br><span class="line">if (user == null) &#123;</span><br><span class="line">    dao.registerUser(mobile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>什么时候使用Checked Exception还是UnChecked Exception？</p>
<h4 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h4><ol>
<li>如果你希望强制你的类调用者来处理异常，那么就用Checked Exception</li>
<li>如果你不希望强制你的类调用者来处理异常，就用Runtime Exception。<br>具体什么时候使用强制还是不强制呢，权衡的依据来自于从业务系统角度出发，如果业务规则定义了调用者应该处理，那么就必须Checked，如果业务规则没有定义，就应该用Runtime Exception<h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4>用户登陆的例子，可能会产生下面这些异常</li>
</ol>
<ul>
<li>IOException (例如读取配置文件找不到) </li>
<li>SQLException (例如连接数据库错误) </li>
<li>ClassNotFoundException(找不到数据库驱动类) </li>
<li>NoSuchUserException (没有对应用户)</li>
<li>PasswordNotMatchException (密码匹配不上)</li>
</ul>
<p>上面3个异常是和业务逻辑无关的系统容错异常，所以应该转换为RuntimeException，不强制类调用者来处理(Spring已经帮我们在框架层面转为Runtime Exception)；而下面两个异常是和业务逻辑相关的流程，从业务实现的角度来说，类调用者必须处理，所以要Checked，强迫调用者去处理(针对提供给外部服务的SDK)。<br>至于上层调用者catch到NoSuchUserException和PasswordNotMatchException怎么处理，也要根据他自己具体的业务逻辑了。如果他有能力处理，就自己处理掉了；或者他不关心这个异常，也不希望上面的类调用者关心，就转化为RuntimeException；或者他希望上面的类调用者处理，而不是自己处理，就转化为本层的异常继续往上抛出来。</p>
<h3 id="《重构》这本书中关于正确使用-Exception-有两个重构方法："><a href="#《重构》这本书中关于正确使用-Exception-有两个重构方法：" class="headerlink" title="《重构》这本书中关于正确使用 Exception 有两个重构方法："></a>《重构》这本书中关于正确使用 Exception 有两个重构方法：</h3><ul>
<li>310 页：Replace Error Code with Exception </li>
<li>315 页：Replace Exception with Test <h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2></li>
</ul>
<ol>
<li>Best Practice for Exception Handling <a href="http://www.onjava.com/pub/a/onjava/2003/11/19/exceptions.html" target="_blank" rel="noopener">http://www.onjava.com/pub/a/onjava/2003/11/19/exceptions.html</a></li>
<li>JAVA 异常设计原则 <a href="http://www.iteye.com/topic/857443" target="_blank" rel="noopener">http://www.iteye.com/topic/857443</a></li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2017/11/11/从ELK 到 EFK/" class="prev">PREV</a><a href="/2017/09/23/一个项目怎么开发出来的？/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2018 <a href="http://tylercao.coding.me/blog">曹林华</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>